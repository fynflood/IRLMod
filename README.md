# IRLMod
![image](https://github.com/user-attachments/assets/e856b1a1-2cbd-4147-ab3e-740bd56bbfd9)
[https://www.youtube.com/watch?v=EfvoVM1tczU](https://youtu.be/sWJuJLrVDGw)

# GM-Side Features:
## Dedicated Player View Launcher:
- A button in the GM's scene controls to open a new browser window/tab pre-configured for a specific "player view" username (e.g., "ScreenGoblin"). This window is intended for a secondary display/TV.
## Viewport Overlay (Table View Definition):
- A toggleable, draggable, and resizable overlay on the GM's canvas.
- This overlay (with a fixed 16:9 aspect ratio) defines the rectangular area of the GM's current scene view that will be sent to the player screen.
- Visual feedback: border style changes if a splash screen is active on the player view.
## Overlay Controls:
- Sync to Player/Table: A button on the overlay to send the currently defined overlay view (position, dimensions) to the player screen, causing the player screen to pan and zoom to match that view.
- Calibrate TV/Grid: A button to automatically resize and center the overlay based on GM-defined settings for the physical TV's width (inches), resolution (pixels), and a desired physical grid size on the TV (e.g., 1-inch squares). This helps match the digital grid to a physical grid overlay if used.
- Close Overlay: A button to hide the GM's viewport overlay.
## Player Screen Splash Image Control:
- A button in the GM's scene controls to toggle a splash image on the player screen.
- The image URL is configured in module settings. When active, the splash image covers the player screen, hiding the map.
## Settings Configuration:
- Module settings allow the GM to configure:
- The dedicated player username.
- The URL for the splash image.
- TV physical dimensions and resolution for calibration.
- Desired physical grid size on the TV for calibration.
- IP address and Port for the Raspberry Pi touch input server.
# Player Client-Side Features (For the "ScreenGoblin" user):
## Clean Player View UI:
- Automatically hides most standard Foundry VTT interface elements (sidebar, navigation, chat, hotbar, controls, pop-up windows, etc.) to provide a clean map-only display suitable for a player-facing TV.
- Disables standard canvas interactions for this user (pan, zoom, context menu) to prevent accidental view changes by mouse/keyboard on the player screen.
## Receives GM View Sync:
- Listens for commands from the GM to update its view (pan/zoom) to match the GM's defined overlay rectangle.
## Displays Splash Image:
- Shows or hides a full-screen splash image based on commands from the GM. When the splash is active, the map canvas is hidden.
## Raspberry Pi IR Touch Frame Integration:
- Connects via WebSocket to a Python server running on a Raspberry Pi that processes input from a USB IR touch frame.
## Multi-Touch Token Movement:
- Handles touch_down, touch_move, and touch_up (or tap_mt) events from the Pi, each associated with a unique touch ID.
- Allows multiple physical miniatures (each representing a touch point) to independently move their corresponding virtual tokens on the Foundry canvas.
- When a touch starts on a token (and that token is controllable by the player view user and not already being dragged by another touch), that touch "grabs" that token.
- Subsequent movement of that physical touch drags the associated virtual token. The visual update is local and immediate on the player screen.
- When the touch ends, the token's final position is snapped to the grid and an update is sent to the server to persist the move for all clients.
## Tap-to-Select for Vision Focus:
- A quick tap (touch down then up with minimal movement) on a token makes that token "controlled" by the player view user in Foundry's UI. This typically makes Foundry display vision and FoW from that token's perspective.
- Tapping an already controlled token deselects it.
- Tapping empty space deselects all tokens.
## Movement Restriction (Game Paused):
- Prevents Pi-driven token movement if the game is paused (unless the player view user is a GM).
- Basic "Phantom Touch" Debounce: Includes a simple client-side mechanism to try and filter out very rapid, close-proximity new touches that might be generated by complex miniature shapes on the IR frame.

